# 通过接口调用Alluxio Engine的LoadData

## 相关链接

PR：<https://github.com/fluid-cloudnative/fluid/pull/542>

issue：<https://github.com/fluid-cloudnative/fluid/issues/295>

## 代码改动与设计

### 1. pkg/controllers/v1alpha1/dataload/implement.go

将原来reconcileLoadDataLoad()方法中第1，2步逻辑放到alluxio engine中。现在，通过ddc.CreateDataLoad()方法创建一个公共的接口dataloadImplement，然后调用dataloadImplement的CreateDataLoadJob重新应用之前的逻辑，实现通过接口调用Alluxio Engine的LoadData。创建engine时能够根据runtimeType的种类去创建不同的engine，LoadData也能相应的有不同的实现。

```go
...
	dataloadImplement, err := ddc.CreateDataLoad(ctx, boundedRuntime.Type)
	if err != nil {
		log.Error(err, "failed to create dataloadimplement")
		return utils.RequeueIfError(err)
	}

	releaseName, jobName, err := dataloadImplement.CreateDataLoadJob(ctx)
	if err != nil {
		return utils.RequeueIfError(err)
	}
...
```

### 2. pkg/ddc/factory.go

factory.go负责实现通过runtimeType去创建不同的engine这部分逻辑，通过map将不同的runtime类型绑定到不同的build函数。

```go
...
func init() {
	buildFuncMap = map[string]buildFunc{
		"alluxio": alluxio.Build,
		"jindo":   jindo.Build,
	}

	buildDataLoadFuncMap = map[string]buildDataLoadFunc{
		"alluxio": alluxio.BuildDataLoad,
	}
}

/**
* Build DataLoadImplement
 */
func CreateDataLoad(ctx requestcontext.ReconcileRequestContext, runtimeType string) (dataloadImplement base.DataLoadImplement, err error) {
	if buildDataLoadFunc, found := buildDataLoadFuncMap[runtimeType]; found {
		dataloadImplement = buildDataLoadFunc(ctx, runtimeType)
	} else {
		err = fmt.Errorf("failed to build the dataloadImplement due to the type %s is not found", ctx.NamespacedName)
	}
	return
}
...
```

### 3. pkg/ddc/alluxio/engine.go

增加BuildDataLoad方法，初始化并返回一个DataloadImplement接口(engine)。

```go
...
// BuildDataLoad function builds the alluxio DataLoadImplement
func BuildDataLoad(ctx requestcontext.ReconcileRequestContext, runtimeType string) base.DataLoadImplement {
	dataloadimplement := &AlluxioEngine{
		name:        ctx.Name,
		namespace:   ctx.Namespace,
		Log:         ctx.Log,
		Client:      ctx.Client,
		runtimeType: runtimeType,
	}
	return dataloadimplement
}
```

### 4. pkg/ddc/base/engine.go

添加DataLoadImplement接口。

```go
...
type DataLoadImplement interface {
	// CreateDataLoadJob load the data
	CreateDataLoadJob(ctx requestcontext.ReconcileRequestContext) (string, string, error)
}

```

### 5. pkg/ddc/alluxio/load_data.go

新增load_data.go文件，其中的内容是AlluxioEngine对CreateDataLoadJob的具体实现，也就是原来`pkg/controllers/v1alpha1/dataload/implement.go`文件中reconcileLoadDataLoad()方法中第1，2步逻辑。

```go
...
// LoadData load the data
func (e *AlluxioEngine) CreateDataLoadJob(ctx requestcontext.ReconcileRequestContext) (releaseName string, jobName string, err error) {
	log := ctx.Log.WithName("createDataLoadJob")

	// 1. Check if the helm release already exists
	releaseName = utils.GetDataLoadReleaseName(ctx.Name)
	jobName = utils.GetDataLoadJobName(releaseName)
	var existed bool
	existed, err = helm.CheckRelease(releaseName, ctx.Namespace)
	if err != nil {
		log.Error(err, "failed to check if release exists", "releaseName", releaseName, "namespace", ctx.Namespace)
		return releaseName, jobName, err
	}

	// 2. install the helm chart if not exists and requeue
	if !existed {
		log.Info("DataLoad job helm chart not installed yet, will install")
		valueFileName, err := e.generateDataLoadValueFile(ctx.DataLoad)
		if err != nil {
			log.Error(err, "failed to generate dataload chart's value file")
			return releaseName, jobName, err
		}
		chartName := utils.GetChartsDirectory() + "/" + cdataload.DATALOAD_CHART
		err = helm.InstallRelease(releaseName, ctx.Namespace, valueFileName, chartName)
		if err != nil {
			log.Error(err, "failed to install dataload chart")
			return releaseName, jobName, err
		}
	}
	return releaseName, jobName, err
}

// generateDataLoadValueFile builds a DataLoadValue by extracted specifications from the given DataLoad, and
// marshals the DataLoadValue to a temporary yaml file where stores values that'll be used by fluid dataloader helm chart
func (e *AlluxioEngine) generateDataLoadValueFile(dataload v1alpha1.DataLoad) (valueFileName string, err error) {
	targetDataset, err := utils.GetDataset(e.Client, dataload.Spec.Dataset.Name, dataload.Spec.Dataset.Namespace)
	if err != nil {
		return "", err
	}

	imageName := "registry.cn-huhehaote.aliyuncs.com/alluxio/alluxio"
	imageTag := "2.3.0-SNAPSHOT-238b7eb"
	imageName, imageTag = docker.GetImageRepoTagFromEnv(common.ALLUXIO_DATALOAD_IMAGE_ENV, imageName, imageTag)
	image := fmt.Sprintf("%s:%s", imageName, imageTag)

	dataloadInfo := cdataload.DataLoadInfo{
		BackoffLimit:  3,
		TargetDataset: dataload.Spec.Dataset.Name,
		LoadMetadata:  dataload.Spec.LoadMetadata,
		Image:         image,
	}

	targetPaths := []cdataload.TargetPath{}
	for _, target := range dataload.Spec.Target {
		fluidNative := isTargetPathUnderFluidNativeMounts(target.Path, *targetDataset)
		targetPaths = append(targetPaths, cdataload.TargetPath{
			Path:        target.Path,
			Replicas:    target.Replicas,
			FluidNative: fluidNative,
		})
	}
	dataloadInfo.TargetPaths = targetPaths
	dataLoadValue := cdataload.DataLoadValue{DataLoadInfo: dataloadInfo}
	data, err := yaml.Marshal(dataLoadValue)
	if err != nil {
		return
	}

	valueFile, err := ioutil.TempFile(os.TempDir(), fmt.Sprintf("%s-%s-loader-values.yaml", dataload.Namespace, dataload.Name))
	if err != nil {
		return
	}
	err = ioutil.WriteFile(valueFile.Name(), data, 0400)
	if err != nil {
		return
	}
	return valueFile.Name(), nil
}

// isTargetPathUnderFluidNativeMounts checks if targetPath is a subpath under some given native mount point.
// We check this for the reason that native mount points need extra metadata sync operations.
func isTargetPathUnderFluidNativeMounts(targetPath string, dataset v1alpha1.Dataset) bool {
	for _, mount := range dataset.Spec.Mounts {
		mountPointOnDDCEngine := fmt.Sprintf("/%s", mount.Name)
		if mount.Path != "" {
			mountPointOnDDCEngine = mount.Path
		}

		//todo(xuzhihao): HasPrefix is not enough.
		if strings.HasPrefix(targetPath, mountPointOnDDCEngine) &&
			(strings.HasPrefix(mount.MountPoint, common.PathScheme) || strings.HasPrefix(mount.MountPoint, common.VolumeScheme)) {
			return true
		}
	}
	return false
}
```

### 6. pkg/controllers/v1alpha1/requestcontext/dataload_ctx.go

由于ddc.CreateDataLoad(ctx, boundedRuntime.Type)和dataloadImplement.CreateDataLoadJob(ctx)方法都需要ReconcilRequestContext类型的参数，这会导致包ddc和包dataload会互相依赖，出现错误。因此我新建了一个包requestcontext，将ReconcileRequestContext结构体放到该包下，让ddc去依赖这个包，解决包之间互相依赖的问题，同时为了适应代码逻辑的改动，为ReconcileRequestContext新增client属性。

```go
...
package requestcontext

import (
	"context"
	datav1alpha1 "github.com/fluid-cloudnative/fluid/api/v1alpha1"
	"github.com/go-logr/logr"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// ReconcileRequestContext wraps up necessary info for reconciliation
type ReconcileRequestContext struct {
	context.Context
	types.NamespacedName
	client.Client
	Log      logr.Logger
	DataLoad datav1alpha1.DataLoad
}
```



