# 通过接口调用Alluxio Engine的LoadData

## 相关链接

PR：<https://github.com/fluid-cloudnative/fluid/pull/542>

issue：<https://github.com/fluid-cloudnative/fluid/issues/295>

## 代码改动与设计

### 1. 为Engine添加方法

为Engine添加两个方法，分别为：

- LoadData()负责创建与DataLoad相关的Job来加载数据。
- Ready()检查Runtime是否和Dataset绑定且已经ready。

**pkg/ddc/base/engine.go**

```go
type Engine interface {
	...
	// LoadData load the data
	LoadData(ctx cruntime.ReconcileRequestContext, targetDataload datav1alpha1.DataLoad) (string, string, error)

	// Ready check if the runtime is ready
	Ready(ctx cruntime.ReconcileRequestContext) bool
}
```

为Implement接口添加上述LoadData()和Ready()方法。

**pkg/ddc/base/engine.go**

```go
type Implement interface {
    ...
    // LoadData load the data
	LoadData(ctx cruntime.ReconcileRequestContext, targetDataload datav1alpha1.DataLoad) (string, string, error)

	// Ready check if the runtime is ready
	Ready(ctx cruntime.ReconcileRequestContext) bool
}
```

TemplateEngine实现Engine中的LoadData()和Ready()方法。

**pkg/ddc/base/load_data.go**

```go
...
// Load the data
func (t *TemplateEngine) LoadData(ctx cruntime.ReconcileRequestContext, targetDataload datav1alpha1.DataLoad) (string, string, error) {
	return t.Implement.LoadData(ctx, targetDataload)
}

// Check if the runtime is ready
func (t *TemplateEngine) Ready(ctx cruntime.ReconcileRequestContext) bool{
	return t.Implement.Ready(ctx)
}

```

### 2. AlluxioEngine和JindoEngine实现Implement接口的方法

AlluxioEngine和JindoEngine都实现了Implement接口，其中要有LoadData()和Ready()方法的具体实现。

**pkg/ddc/alluxio/load_data.go**

```go
...
// LoadData load the data
func (e *AlluxioEngine) LoadData(ctx cruntime.ReconcileRequestContext, targetDataload datav1alpha1.DataLoad) (releaseName string, jobName string, err error) {
	log := ctx.Log.WithName("createDataLoadJob")

	// 1. Check if the helm release already exists
	releaseName = utils.GetDataLoadReleaseName(ctx.Name)
	jobName = utils.GetDataLoadJobName(releaseName)
	var existed bool
	existed, err = helm.CheckRelease(releaseName, ctx.Namespace)
	if err != nil {
		log.Error(err, "failed to check if release exists", "releaseName", releaseName, "namespace", ctx.Namespace)
		return releaseName, jobName, err
	}

	// 2. install the helm chart if not exists and requeue
	if !existed {
		log.Info("DataLoad job helm chart not installed yet, will install")
		valueFileName, err := e.generateDataLoadValueFile(targetDataload)
		if err != nil {
			log.Error(err, "failed to generate dataload chart's value file")
			return releaseName, jobName, err
		}
		chartName := utils.GetChartsDirectory() + "/" + cdataload.DATALOAD_CHART
		err = helm.InstallRelease(releaseName, ctx.Namespace, valueFileName, chartName)
		if err != nil {
			log.Error(err, "failed to install dataload chart")
			return releaseName, jobName, err
		}
	}
	return releaseName, jobName, err
}

// generateDataLoadValueFile builds a DataLoadValue by extracted specifications from the given DataLoad, and
// marshals the DataLoadValue to a temporary yaml file where stores values that'll be used by fluid dataloader helm chart
func (e *AlluxioEngine) generateDataLoadValueFile(targetDataload datav1alpha1.DataLoad) (valueFileName string, err error) {
	targetDataset, err := utils.GetDataset(e.Client, targetDataload.Spec.Dataset.Name, targetDataload.Spec.Dataset.Namespace)
	if err != nil {
		return "", err
	}

	imageName := "registry.cn-huhehaote.aliyuncs.com/alluxio/alluxio"
	imageTag := "2.3.0-SNAPSHOT-238b7eb"
	imageName, imageTag = docker.GetImageRepoTagFromEnv(common.ALLUXIO_DATALOAD_IMAGE_ENV, imageName, imageTag)
	image := fmt.Sprintf("%s:%s", imageName, imageTag)

	dataloadInfo := cdataload.DataLoadInfo{
		BackoffLimit:  3,
		TargetDataset: targetDataload.Spec.Dataset.Name,
		LoadMetadata:  targetDataload.Spec.LoadMetadata,
		Image:         image,
	}

	targetPaths := []cdataload.TargetPath{}
	for _, target := range targetDataload.Spec.Target {
		fluidNative := isTargetPathUnderFluidNativeMounts(target.Path, *targetDataset)
		targetPaths = append(targetPaths, cdataload.TargetPath{
			Path:        target.Path,
			Replicas:    target.Replicas,
			FluidNative: fluidNative,
		})
	}
	dataloadInfo.TargetPaths = targetPaths
	dataLoadValue := cdataload.DataLoadValue{DataLoadInfo: dataloadInfo}
	data, err := yaml.Marshal(dataLoadValue)
	if err != nil {
		return
	}

	valueFile, err := ioutil.TempFile(os.TempDir(), fmt.Sprintf("%s-%s-loader-values.yaml", targetDataload.Namespace, targetDataload.Name))
	if err != nil {
		return
	}
	err = ioutil.WriteFile(valueFile.Name(), data, 0400)
	if err != nil {
		return
	}
	return valueFile.Name(), nil
}

// isTargetPathUnderFluidNativeMounts checks if targetPath is a subpath under some given native mount point.
// We check this for the reason that native mount points need extra metadata sync operations.
func isTargetPathUnderFluidNativeMounts(targetPath string, dataset datav1alpha1.Dataset) bool {
	for _, mount := range dataset.Spec.Mounts {
		mountPointOnDDCEngine := fmt.Sprintf("/%s", mount.Name)
		if mount.Path != "" {
			mountPointOnDDCEngine = mount.Path
		}

		//todo(xuzhihao): HasPrefix is not enough.
		if strings.HasPrefix(targetPath, mountPointOnDDCEngine) &&
			(strings.HasPrefix(mount.MountPoint, common.PathScheme) || strings.HasPrefix(mount.MountPoint, common.VolumeScheme)) {
			return true
		}
	}
	return false
}

// Ready check if the alluxioruntime is ready
func (e *AlluxioEngine) Ready(ctx cruntime.ReconcileRequestContext) (ready bool) {
	runtimeName := e.runtime.Name
	runtimeNamespace := e.runtime.Namespace
	podName := fmt.Sprintf("%s-master-0", runtimeName)
	containerName := "alluxio-master"
	fileUtils := operations.NewAlluxioFileUtils(podName, containerName, runtimeNamespace, ctx.Log)
	ready = fileUtils.Ready()
	return ready
}
```

**pkg/ddc/jindo/load_data.go**

```go
...
// LoadData load the data
func (e *JindoEngine) LoadData(ctx cruntime.ReconcileRequestContext, targetDataload datav1alpha1.DataLoad) (releaseName string, jobName string, err error) {
	// todo
	return releaseName, jobName, err
}

// Ready check if the jindoruntime is ready
func (e *JindoEngine) Ready(ctx cruntime.ReconcileRequestContext) (ready bool) {
    // todo
	return ready
}
```

### 3. DataLoad Reconcile时要先创建或获得相应的Engine

为ReconcileRequestContext填充必要的属性，同时创建或获取相应的Engine。

**pkg/controllers/v1alpha1/dataload/dataload_controller.go**

```go
...
func (r *DataLoadReconciler) Reconcile(req ctrl.Request) (ctrl.Result, error) {
	ctx := cruntime.ReconcileRequestContext{
		Context:        context.Background(),
		NamespacedName: req.NamespacedName,
		Log:            r.Log.WithValues("dataload", req.NamespacedName),
		Recorder:		r.Recorder,
		Client:			r.Client,
		Category:		common.AccelerateCategory,
	}

	// 1. Get DataLoad object
	dataload, err := utils.GetDataLoad(r.Client, req.Name, req.Namespace)
	if err != nil {
		if utils.IgnoreNotFound(err) == nil {
			ctx.Log.Info("DataLoad not found")
			return utils.NoRequeue()
		} else {
			ctx.Log.Error(err, "failed to get DataLoad")
			return utils.RequeueIfError(errors.Wrap(err, "failed to get DataLoad info"))
		}
	}
	targetDataload := *dataload
	ctx.Log.V(1).Info("DataLoad found", "detail", dataload)

	// 2. Reconcile deletion of the object if necessary
	if utils.HasDeletionTimestamp(dataload.ObjectMeta) {
		return r.ReconcileDataLoadDeletion(ctx, targetDataload)
	}

	// 3. get the dataset
	targetDataset, err := utils.GetDataset(r.Client, targetDataload.Spec.Dataset.Name, req.Namespace)
	if err != nil {
		if utils.IgnoreNotFound(err) == nil {
			ctx.Log.Info("The dataset is not found", "dataset", ctx.NamespacedName)
			// no datset means no metadata, not necessary to ReconcileDataLoad
			return utils.RequeueAfterInterval(20 * time.Second)
		} else {
			ctx.Log.Error(err, "Failed to get the ddc dataset")
			return utils.RequeueIfError(errors.Wrap(err, "Unable to get dataset"))
		}
	}

	index, boundedRuntime := utils.GetRuntimeByCategory(targetDataset.Status.Runtimes, common.AccelerateCategory)
	if index == -1 {
		ctx.Log.Info("bounded runtime with Accelerate Category is not found on the target dataset", "targetDataset", targetDataset)
		r.Recorder.Eventf(&targetDataload,
			v1.EventTypeNormal,
			common.RuntimeNotReady,
			"Bounded accelerate runtime not ready")
		return utils.RequeueAfterInterval(20 * time.Second)
	}

	ctx.RuntimeType = boundedRuntime.Type

	//4. get the runtime
	switch ctx.RuntimeType {
	case common.ALLUXIO_RUNTIME:
		runtime, err := utils.GetAlluxioRuntime(ctx.Client, boundedRuntime.Name, boundedRuntime.Namespace)
		if err != nil {
			if utils.IgnoreNotFound(err) == nil {
				ctx.Log.V(1).Info("The runtime is not found", "runtime", ctx.NamespacedName)
				return ctrl.Result{}, nil
			} else {
				ctx.Log.Error(err, "Failed to get the ddc runtime")
				return utils.RequeueIfError(errors.Wrap(err, "Unable to get ddc runtime"))
			}
		}
		ctx.Runtime = runtime
		ctx.Log.V(1).Info("get the runtime", "runtime", ctx.Runtime)
	default:
		ctx.Log.Error(fmt.Errorf("RuntimeNotSupported"), "The runtime is not supported yet", "runtime", boundedRuntime)
		r.Recorder.Eventf(&targetDataload,
			v1.EventTypeNormal,
			common.RuntimeNotReady,
			"Bounded accelerate runtime not supported")
	}

	// 5. add finalizer and requeue
	if !utils.ContainsString(targetDataload.ObjectMeta.GetFinalizers(), cdataload.DATALOAD_FINALIZER) {
		return r.addFinalierAndRequeue(ctx, targetDataload)
	}

	// 6. add owner and requeue
	if !utils.ContainsOwners(targetDataload.GetOwnerReferences(), targetDataset) {
		return r.AddOwnerAndRequeue(ctx, targetDataload, targetDataset)
	}

	// 7. create or get engine
	engine, err := r.GetOrCreateEngine(ctx)
	if err != nil{
		r.Recorder.Eventf(&targetDataload, v1.EventTypeWarning, common.ErrorProcessDataLoadReason, "Process DataLoad error %v", err)
		return utils.RequeueIfError(errors.Wrap(err, "Failed to create or get engine"))
	}

	return r.ReconcileDataLoad(ctx, targetDataload, engine)
}
...
```

增加GetOrCreateEngine()方法，创建或获取已创建的Engine，复用之前build的逻辑。

**pkg/controllers/v1alpha1/dataload/dataload_controller.go**

```go
...
// GetOrCreateEngine gets the dataset
func (r *DataLoadReconciler) GetOrCreateEngine(
	ctx cruntime.ReconcileRequestContext) (engine base.Engine, err error) {
	found := false
	id := ddc.GenerateEngineID(ctx.NamespacedName)
	r.mutex.Lock()
	defer r.mutex.Unlock()
	if engine, found = r.engines[id]; !found {
		engine, err = ddc.CreateEngine(id,
			ctx)
		if err != nil {
			return nil, err
		}
		r.engines[id] = engine
		r.Log.V(1).Info("Put Engine to engine map")
	} else {
		r.Log.V(1).Info("Get Engine from engine map")
	}

	return engine, err
}
...
```

### 4. Ready()和LoadData都由Engine调用

判断runtime是否ready，不再用case来判断，而是直接调用Engine的Ready()方法。

**pkg/controllers/v1alpha1/dataload/implement.go**

```go
// reconcilePendingDataLoad reconciles DataLoads that are in `DataLoadPhasePending` phase
func (r *DataLoadReconcilerImplement) reconcilePendingDataLoad(ctx cruntime.ReconcileRequestContext,
	targetDataload datav1alpha1.DataLoad,
	engine base.Engine) (ctrl.Result, error) {
    ...
    // 4. Check if the bounded runtime is ready
	ready := engine.Ready(ctx)
	if !ready {
		log.V(1).Info("Bounded accelerate runtime not ready", "targetDataset", targetDataset)
		r.Recorder.Eventf(&targetDataload,
			v1.EventTypeNormal,
			common.RuntimeNotReady,
			"Bounded accelerate runtime not ready")
		return utils.RequeueAfterInterval(20 * time.Second)
	}
    ...
}
```

创建Job执行LoadData通过调用Engine的LoadData()方法来实现。

**pkg/controllers/v1alpha1/dataload/implement.go**

```go
// reconcileLoadingDataLoad reconciles DataLoads that are in `DataLoadPhaseLoading` phase
func (r *DataLoadReconcilerImplement) reconcileLoadingDataLoad(ctx cruntime.ReconcileRequestContext,
	targetDataload datav1alpha1.DataLoad,
	engine base.Engine) (ctrl.Result, error) {
	...
	releaseName, jobName, err := engine.LoadData(ctx, targetDataload)
	if err != nil {
		return utils.RequeueIfError(err)
	}
	log.Info("DataLoad job helm chart successfullly installed", "namespace", ctx.Namespace, "releaseName", releaseName)
	r.Recorder.Eventf(&targetDataload, v1.EventTypeNormal, common.DataLoadJobStarted, "The DataLoad job %s started", jobName)
    ...
}
```

